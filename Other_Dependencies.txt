# Sentence delimiters
DELIMITERS = "<།>";

LIST ALLPOS = ADJ ADP ADV AUX DET INTJ NOUN NUM PART PRON PROPN PUNCT SCONJ VERB X;

LIST @punct = @punct;
LIST @mark = @mark;
LIST @fixed = @fixed;
LIST @advmod = @advmod;
LIST @case = @case;
LIST @aux-fin = @aux-fin;
LIST @neg = @neg;
LIST @appos = @appos;
LIST @amod = @amod;
LIST @nmod = @nmod;
LIST @det = @det;
LIST @nmod-poss = @nmod-poss;
LIST @nummod = @nummod;
LIST @nmod-pro = @nmod-pro;
LIST @conj = @conj;
LIST @cc = @cc;

LIST >>> = >>> ;
LIST <<< = <<< ;

# Helpers
SET np.elem = (NOUN) OR (ADJ) OR (NUM) OR (PROPN) OR (DET) OR (PRON) OR (VerbForm=Vnoun);

SET excl.agn = (Case=*) - (Case=Agn);

SET LEFT_NP_BOUNDARY = (VERB) OR (ADP) OR (PUNCT) OR (SCONJ) OR (PART) OR (ADV) OR (AUX);
SET RIGHT_NP_BOUNDARY = (ADP) OR (PUNCT) OR (SCONJ) OR (Polarity=Neg);

SET Head_NOUN = (NOUN) OR (NUM) OR (PROPN) OR (PRON) OR (DET) OR (VerbForm=Vnoun);

LIST TAGS = \^arg1 \^arg2 \^arg2-hon \^arg2-lvc \^arg3 \^argcl \^aux \^aux-lvc \^cop \^obl \^obl-adv \^obl-arg;

#DEPENDENCY RULES
# First rules for NP elements, second rules for ADP, PART, SCONJ - in this way I can link ADP as ex to the Head Noun because the other elements will have already a dependency - putting in SETPARENT... TO (NONE P ALLPOS - TAGS). The (NONE p ALLPOS - TAGS) condition allows me to jump NP elements thet have already The Head Noun as a parent.

#NP ELEMENTS:

#propn as adposition
# added condition OR (DET) in the two following rules at the end in order to avoid crossing of nps n+det+n+case - this is because in LEFT_NP_BOUNDARY we did not add (DET). Maybe it can be formulated better adding (DET) or (NUM)? or (ADJ) ? Vedi in sketch engine.. e poi fai regola specifica per il DET..

#rule to solve line 86
SETPARENT (PROPN) (NONE p ALLPOS) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ) OR (NUM)) (-1 TAGS);

SETPARENT (PROPN) (NONE p ALLPOS) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ) OR (NUM))(-1 LEFT_NP_BOUNDARY);
SETPARENT (PROPN) (NONE p ALLPOS) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ) OR (NUM))(-2< (PUNCT));
MAP (@appos) TARGET (PROPN) - TAGS (p Head_NOUN);


#Noun as adposition

#check these cases
#SETPARENT (NOUN)- (\^arg1) - (\^arg2) - (\^obl-arg) - (\^obl-adv) - (\^obl)(NONE p ALLPOS) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ)) (-1 (\^arg1) OR (\^arg2) OR (\^obl-arg) OR (\^obl-adv) OR (\^obl));

SETPARENT (NOUN) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ) OR (NUM))(-1 LEFT_NP_BOUNDARY)(NONE p ALLPOS - TAGS);
SETPARENT (NOUN) (NONE p ALLPOS) TO (-1* Head_NOUN - (DET) BARRIER LEFT_NP_BOUNDARY OR (DET) OR (ADJ) OR (NUM))(-2< (PUNCT));
MAP (@appos) TARGET (NOUN) - TAGS (p Head_NOUN);

#Head_NOUN (without arg labels) + dang

SETPARENT Head_NOUN (1 ("<དང་>"))(NONE p ALLPOS) TO (2 Head_NOUN);
MAP (@conj) TARGET Head_NOUN - TAGS (1 ("<དང་>"))(p Head_NOUN);

#adjectives

#adjectives
#SETPARENT (ADJ) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY)(NONE p ALLPOS - TAGS);
#SETPARENT (ADJ) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT));
#MAP (@amod) TARGET (ADJ) - TAGS (p Head_NOUN);

#possible alternative formulation to deal with cases N + N(arg)+ ADJ - to make the ADJ pointing to the arg instead of the first N
SETPARENT (ADJ) (NONE p ALLPOS) TO (-1* Head_NOUN + TAGS BARRIER LEFT_NP_BOUNDARY);
SETPARENT (ADJ) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
SETPARENT (ADJ) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT));
MAP (@amod) TARGET (ADJ) - TAGS (p Head_NOUN);

#numerals
#SETPARENT (NUM) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY)(NONE p ALLPOS - TAGS);
#SETPARENT (NUM) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT))(NONE p ALLPOS - TAGS);
#MAP (@nummod)TARGET (NUM) - TAGS (p Head_NOUN);

SETPARENT (NUM) (NONE p ALLPOS) TO (-1* Head_NOUN + TAGS BARRIER LEFT_NP_BOUNDARY);
SETPARENT (NUM) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
SETPARENT (NUM) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT))(NONE p ALLPOS - TAGS);
MAP (@nummod)TARGET (NUM) - TAGS (p Head_NOUN);

#pronouns
#SETPARENT (PRON) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY)(NONE p ALLPOS - TAGS);
#SETPARENT (PRON) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT))(NONE p ALLPOS - TAGS);
#MAP (@nmod-pro) TARGET (PRON) - TAGS (p Head_NOUN);

#determiners
#SETPARENT (DET) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
#SETPARENT (DET) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT))(NONE p ALLPOS - TAGS);
#MAP (@det) TARGET (DET) - TAGS (p Head_NOUN);

SETPARENT (DET) (NONE p ALLPOS) TO (-1* Head_NOUN + TAGS BARRIER LEFT_NP_BOUNDARY);
SETPARENT (DET) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
SETPARENT (DET) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT))(NONE p ALLPOS - TAGS);
MAP (@det)TARGET (DET) - TAGS (p Head_NOUN);


#----------PART-------------------------------------------------------------

#adverbs
SETPARENT (PART) (NONE p ALLPOS) TO (-1 (ADV));
MAP (@fixed) TARGET (PART) - TAGS (p (ADV));

#negations
SETPARENT (PART) + (Polarity=Neg)(NONE p ALLPOS) TO (1* (VERB) OR (AUX));
MAP (@neg) TARGET (PART) + (Polarity=Neg)(p (VERB) OR (AUX));

#final sentence suffix + imp
SETPARENT (PART) + (Mood=Ind) OR (PART) + (Mood=Imp)(NONE p ALLPOS) TO (-1* (VERB))(NONE p ALLPOS - TAGS);
MAP (@aux-fin) TARGET (PART) + (Mood=Ind) OR (PART) + (Mood=Imp)(p (VERB));

#'ang / ni after NP

#Cases where the PART follows the CASE after the NP - Rgyal-po-chen-pos[agn]-ni
SETPARENT (PART) (NONE p ALLPOS)(-1 (ADP)) TO (-1* Head_NOUN)(-1 LEFT_NP_BOUNDARY);

SETPARENT (PART) (NONE p ALLPOS) TO (-1* Head_NOUN + TAGS BARRIER LEFT_NP_BOUNDARY);
SETPARENT (PART) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
SETPARENT (PART) (NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT));
MAP (@case) TARGET (PART) - TAGS (p (VERB));

#'ang after verbs as coordinative
SETPARENT (PART) (NONE p ALLPOS) TO (-1* (VERB))(NONE p ALLPOS - TAGS);
MAP (@mark) TARGET (PART) - TAGS (p (VERB));

#-------------ADP------------------------------------------------------------
#rule to prevent cases DET + arg2 - DET + obl-adv/obl/obl-arg - ADP (ter), in order to set dependencies between ADP and obl-adv and not  between ADP and arg2 (Es: 12570) - we cannot put a barriier condition in this cases because we have a DET on the left.

#dang - associative

SETPARENT (Case=Com)(NOT 1 (PUNCT))(NONE p ALLPOS) TO (-1 Head_NOUN);
MAP (@cc) TARGET (Case=Com)(NOT 1 (PUNCT))(p Head_NOUN);

#dang - associative with VN
SETPARENT (Case=Com)(1 (PUNCT))(NONE p ALLPOS) TO (-1 (VerbForm=Vnoun));
MAP (@case) TARGET (Case=Com)(1 (PUNCT))(p Head_NOUN);

#general rule using the oblique tags

SETPARENT (ADP) (NONE p ALLPOS) TO (-1* Head_NOUN + (\^obl-adv) OR Head_NOUN + (\^obl) OR Head_NOUN + (\^obl-arg) BARRIER LEFT_NP_BOUNDARY);

#genitive + pron:
SETPARENT (Case=Gen)(NONE p ALLPOS) TO (-1 (PRON));


#genitive - for nested clauses: to prevent cases N (arg) + N + .... + Gen where Gen is pointoing tho the first noun.
SETPARENT (Case=Gen)(NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY OR (\^arg1) OR (\^arg2) OR (\^obl-arg) OR (\^obl-adv));

#terminative - for nested clauses: to prevent cases N (arg1) + N +...+ Ter where Ter is pointing to the first noun and the second noun does not have  an ^obl tag.
SETPARENT (Case=Ter)(NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY OR (\^arg1) OR (\^arg2));


#general rule
SETPARENT (ADP) (NONE p ALLPOS) TO (-1* Head_NOUN + TAGS BARRIER LEFT_NP_BOUNDARY);
SETPARENT (ADP)(NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-1 LEFT_NP_BOUNDARY);
SETPARENT (ADP)(NONE p ALLPOS) TO (-1* Head_NOUN BARRIER LEFT_NP_BOUNDARY)(-2< (PUNCT));

MAP (@case) TARGET (ADP) - TAGS (p Head_NOUN);


#------------SCONJ---------------------------------------------------------------


#adverbs as shin-tu
SETPARENT (SCONJ)(NONE p ALLPOS) TO (-1 (ADV));
MAP (@fixed) TARGET (SCONJ) - TAGS (p (ADV));

SETPARENT (SCONJ)(NONE p ALLPOS) TO (-1 (AUX))(NOT -2 (VERB))(NONE p ALLPOS - TAGS);
SETPARENT (SCONJ)(NONE p ALLPOS) TO (-1* (VERB))(NONE p ALLPOS - TAGS);

#converbs
MAP (@mark) TARGET (SCONJ) - TAGS (p (VERB));


#------------ADV-----------------------------------------------------------------
#Insert (NONE p ALLPOS - TAGS) to link the ADV to the root verb - with no parents

SETPARENT (ADV) TO (1* (VERB))(NONE p ALLPOS - TAGS);
MAP (@advmod) TARGET (ADV) - TAGS (p (VERB));


#------------PUNCT----------------------------------------------------------------
#better to indicate an interval to the left of PUNCT? Insert (NONE p ALLPOS - TAGS) to link the PUNCT to the root verb - with no parents

SETPARENT (PUNCT) TO (-1* (VERB))(NONE p ALLPOS - TAGS);
MAP (@punct) TARGET (PUNCT) - TAGS (p (VERB));


#Head_NOUN GENITIVE MODIFIER------------------------------------------------------

SETPARENT Head_NOUN - TAGS (NONE p ALLPOS) TO (1* Head_NOUN BARRIER LEFT_NP_BOUNDARY - (Case=Gen) OR TAGS)(-1 (Case=Gen));
MAP (@nmod) TARGET Head_NOUN - TAGS (p Head_NOUN);


#SUBSTITUTE RULES FOR SPECIFIC CASES:

#This SUBSITUTE rule is removing the @appos tag in cases like:
#N(arg1/2)+[N+....+Ter]+...+V and is linked to the rule for the Terminative in the ADP section where we avoided the dependency of the Ter with a Head_NOUN that has already an arg tag. The Head_NOUN for the terminative is the second NOUN and this is why we have to remove the @appos tag.

SUBSTITUTE (@appos)(*) TARGET (NOUN) + (@appos)(c (ADP));

END

#mancano i casi tipo ablativo, frasi temporali di luogo, i nomi con il genitivo, alcuni pronomi interrogativi. Rivedi se toglier i NUM come HEAD NOUN
